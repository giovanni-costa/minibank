import { BadRequestException, HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { CreateTransferDto } from './dto/create-transfer.dto';
import { UpdateTransferDto } from './dto/update-transfer.dto';
import { PrismaService } from 'src/PrismaService';
import * as bcrypt from 'bcrypt'

@Injectable()
export class TransfersService {

  constructor(private prisma:PrismaService){}

  async create(data: CreateTransferDto, password: string) {

    const userData = await this.validateCredentials(data.sender, password)

    if(!userData) { 
      throw new HttpException('Invalid Credentials', HttpStatus.BAD_REQUEST)
    }

    // Throws Error if an ID is given
    if(data.id) { 
      throw new HttpException('IDs are autogenerated', HttpStatus.BAD_REQUEST)
    }
    // Throws Error if a Date is given
    if(data.date) { 
      throw new HttpException('Dates are autogenerated', HttpStatus.BAD_REQUEST)
    }

    // Find Receiver and Sender
    const senderData = await this.prisma.miniBanco.findFirst({
      where:{id:data.sender}
    })

    const receiverData = await this.prisma.miniBanco.findFirst({
      where:{id:data.receiver}
    })

    // Cannot send to self
    if(data.sender === data.receiver) { 
      throw new HttpException('Cannot send to yourself', HttpStatus.BAD_REQUEST)
    }

    // Throw Error if Funds are not enough
    if(senderData.amount.toNumber() < data.value || data.value <= 0) { 
      throw new HttpException('Not enough funds', HttpStatus.BAD_REQUEST)
    }

    // Update funds for peers
    await this.prisma.miniBanco.update({
      data: {amount: senderData.amount.toNumber() - parseFloat(data.value.toString())},
      where:{
        id : senderData.id
      }
    })

    await this.prisma.miniBanco.update({
      data: {amount: receiverData.amount.toNumber() + parseFloat(data.value.toString())},
      where:{
        id : receiverData.id
      }
    })

    const create = await this
      .prisma
      .transfers
      .create({
        data,
      })

    return create;
  }

  async findAll() {
    return await this.prisma.transfers.findMany();
  }

  async findLast(id: string) {

    return await this.prisma.transfers.findMany({
      take: 10,
      where:{
        OR:[
          {
            sender:id
          },{
            receiver: id
          }
        ]
      },
      orderBy: {
        date: 'desc'
      }
    })
  }

/*   update(id: number, updateTransferDto: UpdateTransferDto) {
    return `This action updates a #${id} transfer`;
  }

  remove(id: number) {
    return `This action removes a #${id} transfer`;
  } */
  async validateCredentials(id:string, password:string){

    const userData = await this.prisma.miniBanco.findFirstOrThrow({
      where: { id: id }
    })

    if(userData.id === id && bcrypt.compareSync(password, userData.password)){
      return userData;
    }    
  }
}
